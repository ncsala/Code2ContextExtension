// src/application/services/tree/FilesTreeGenerator.ts
import * as path from "path";
import { Ignore } from "ignore";
import { toPosix } from "../../../shared/utils/pathUtils";
import { FileTree } from "../../../domain/model/FileTree";
import { DirectoryTreeGenerator } from "./DirectoryTreeGenerator";
import { BaseTreeGenerator } from "./BaseTreeGenerator";
import { TreeLimits, MeasuredEntry } from "./common";

export class FilesTreeGenerator extends BaseTreeGenerator {
  constructor(l: Partial<TreeLimits> = {}) {
    super({ maxTotal: l.maxTotal ?? 150, maxChildren: l.maxChildren ?? 30 });
  }

  public async build(
    dirFs: string,
    ig: Ignore,
    root: string
  ): Promise<{ node: FileTree; count: number }> {
    const rel = toPosix(path.relative(root, dirFs));
    const isRoot = rel === "";

    /* 0️⃣  ¿todo seleccionado? → delegamos al modo “directory”  */
    const maybeDelegated = await this.tryDelegateToDirectory(
      dirFs,
      ig,
      root,
      rel
    );
    if (maybeDelegated) return maybeDelegated;

    /* 1️⃣  medir */
    const { entries, totalDesc } = await this.measure(dirFs, ig, root);

    /* 2️⃣  bypass si raíz o selección dentro */
    if (
      isRoot ||
      this.hasSelectionInside(rel) ||
      (entries.length <= this.limits.maxChildren &&
        totalDesc <= this.limits.maxTotal)
    ) {
      return this.expandAll(rel, entries, ig, root, isRoot, true);
    }

    /* 3️⃣  truncado + ensamblado */
    return this.assemble(rel, entries, totalDesc, ig, root);
  }

  /* ───────── helpers específicos ───────── */

  private async tryDelegateToDirectory(
    dirFs: string,
    ig: Ignore,
    root: string,
    rel: string
  ): Promise<{ node: FileTree; count: number } | null> {
    const selectedInside = [...this.selected].filter((s) =>
      s.startsWith(rel === "" ? "" : rel + "/")
    );
    if (!selectedInside.length) return null;

    const totalFiles = await this.countDescendantFiles(dirFs, ig, root);
    if (selectedInside.length !== totalFiles) return null;

    const dirGen = new DirectoryTreeGenerator(this.limits);
    const { fileTree, truncatedPaths } = await dirGen.generatePrunedTreeText(
      dirFs,
      ig,
      []
    );
    /* Prefijar paths truncados */
    for (const p of truncatedPaths) {
      this.truncated.add(rel === "" ? p : `${rel}/${p}`);
    }
    fileTree.path = rel;
    this.fixTreePaths(fileTree, rel);
    return { node: fileTree, count: this.countTree(fileTree) };
  }

  private async measure(dirFs: string, ig: Ignore, root: string) {
    const entries = await this.listRelevantEntries(dirFs, ig, root);
    const measured = await this.measureEntries(entries, dirFs, ig, root);
    const totalDesc = measured.reduce((s, e) => s + e.cnt, 0);
    return { entries: measured, totalDesc };
  }

  private async assemble(
    rel: string,
    measured: MeasuredEntry[],
    totalDesc: number,
    ig: Ignore,
    root: string
  ) {
    const [heavy, rest] = this.applyHeavyTruncation(measured, totalDesc);
    const [small, middle, large] = this.applySmartTruncation(rest, totalDesc);

    const children: FileTree[] = [];
    let count = 0;
    const push = (n: FileTree, cnt: number) => {
      children.push(n);
      count += cnt;
    };

    heavy.forEach((h) => push(h.node, h.count));

    const handle = async (m: MeasuredEntry) => {
      if (m.entry.isDirectory()) {
        const sub = await this.build(m.abs, ig, root);
        push(sub.node, sub.count);
      } else push({ name: m.entry.name, path: m.rel, isDirectory: false }, 1);
    };

    for (const s of small) await handle(s);
    if (middle.length)
      push(
        this.middlePlaceholder(middle),
        middle.reduce((a, m) => a + m.cnt, 0)
      );
    for (const l of large) await handle(l);

    return {
      node: {
        name: path.basename(rel || root),
        path: rel,
        isDirectory: true,
        children,
      },
      count,
    };
  }

  /* Mantiene ruta coherente cuando delegamos */
  private fixTreePaths(node: FileTree, prefix: string): void {
    if (prefix === "" || !node.children) return;
    for (const child of node.children) {
      if (child.name.startsWith("[ ")) continue; // placeholder
      child.path =
        child.path && !child.path.startsWith(prefix)
          ? `${prefix}/${child.path}`
          : child.path;
      if (child.isDirectory) this.fixTreePaths(child, prefix);
    }
  }
}
